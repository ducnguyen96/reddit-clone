// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type RegisterResult interface {
	IsRegisterResult()
}

type Comment struct {
	ID          string           `json:"id"`
	PostID      string           `json:"postID"`
	Content     string           `json:"content"`
	ContentMode InputContentMode `json:"contentMode"`
	CreatedAt   string           `json:"createdAt"`
	UpdatedAt   string           `json:"updatedAt"`
	UpVotes     int              `json:"upVotes"`
	DownVotes   int              `json:"downVotes"`
	Owner       *User            `json:"owner"`
	IsUpVoted   bool             `json:"isUpVoted"`
	IsDownVoted bool             `json:"isDownVoted"`
	Replies     []*Comment       `json:"replies"`
}

type CommentPagination struct {
	Length      int        `json:"length"`
	CurrentPage int        `json:"currentPage"`
	Comments    []*Comment `json:"comments"`
}

type Community struct {
	ID             string        `json:"id"`
	Name           string        `json:"name"`
	Slug           string        `json:"slug"`
	Type           CommunityType `json:"type"`
	IsAdult        bool          `json:"isAdult"`
	CreatedAt      string        `json:"createdAt"`
	UpdatedAt      string        `json:"updatedAt"`
	NumberOfMember int           `json:"numberOfMember"`
}

type CommunityPagination struct {
	Length      int          `json:"length"`
	CurrentPage int          `json:"currentPage"`
	Communities []*Community `json:"communities"`
}

type CreateCommentInput struct {
	PostID      string           `json:"postID"`
	ParentID    *string          `json:"parentID"`
	Content     string           `json:"content"`
	ContentMode InputContentMode `json:"contentMode"`
}

type CreateCommunityInput struct {
	Name    string        `json:"name"`
	Type    CommunityType `json:"type"`
	IsAdult bool          `json:"isAdult"`
}

type CreateMediaInput struct {
	URL  string    `json:"url"`
	Type MediaType `json:"type"`
}

type CreatePostInput struct {
	Title       string           `json:"title"`
	Content     string           `json:"content"`
	Type        PostType         `json:"type"`
	ContentMode InputContentMode `json:"contentMode"`
	CommunityID string           `json:"communityId"`
}

type CustomError struct {
	Message string `json:"message"`
	Path    string `json:"path"`
}

type Media struct {
	ID        string    `json:"id"`
	URL       string    `json:"url"`
	Type      MediaType `json:"type"`
	CreatedAt string    `json:"createdAt"`
	UpdatedAt string    `json:"updatedAt"`
}

type Post struct {
	ID               string           `json:"id"`
	Title            string           `json:"title"`
	Slug             string           `json:"slug"`
	Content          string           `json:"content"`
	Type             PostType         `json:"type"`
	ContentMode      InputContentMode `json:"contentMode"`
	UpVotes          int              `json:"upVotes"`
	DownVotes        int              `json:"downVotes"`
	CreatedAt        string           `json:"createdAt"`
	UpdatedAt        string           `json:"updatedAt"`
	Community        *Community       `json:"community"`
	Owner            *User            `json:"owner"`
	NumberOfComments int              `json:"numberOfComments"`
	IsUpVoted        bool             `json:"isUpVoted"`
	IsDownVoted      bool             `json:"isDownVoted"`
}

type PostPagination struct {
	Length      int     `json:"length"`
	CurrentPage int     `json:"currentPage"`
	Posts       []*Post `json:"posts"`
}

type QueryCommentInput struct {
	PostID   string  `json:"postID"`
	ParentID *string `json:"parentID"`
	Limit    *int    `json:"limit"`
	Page     *int    `json:"page"`
}

type QueryCommunityInput struct {
	Limit    *int  `json:"limit"`
	Page     *int  `json:"page"`
	OnlyMine *bool `json:"onlyMine"`
}

type QueryPostInput struct {
	Limit *int          `json:"limit"`
	Page  *int          `json:"page"`
	Sort  *SortPostEnum `json:"sort"`
}

type RegisterBadRequest struct {
	Errors []*CustomError `json:"errors"`
}

func (RegisterBadRequest) IsRegisterResult() {}

type RegisterInternalServerError struct {
	Error *CustomError `json:"error"`
}

func (RegisterInternalServerError) IsRegisterResult() {}

type RegisterPayload struct {
	User  *User            `json:"user"`
	Token *TokenPayloadDto `json:"token"`
}

func (RegisterPayload) IsRegisterResult() {}

type TokenPayloadDto struct {
	ExpiresIn   *int    `json:"expiresIn"`
	AccessToken *string `json:"accessToken"`
}

type User struct {
	ID        string  `json:"id"`
	Username  string  `json:"username"`
	Email     *string `json:"email"`
	Avatar    *string `json:"avatar"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type UserAction struct {
	ID         string               `json:"id"`
	Type       UserActionType       `json:"type"`
	Target     string               `json:"target"`
	TargetType UserActionTargetType `json:"targetType"`
	CreatedAt  string               `json:"createdAt"`
	UpdatedAt  string               `json:"updatedAt"`
}

type UserCreateActionInput struct {
	Type       UserActionType       `json:"type"`
	Target     string               `json:"target"`
	TargetType UserActionTargetType `json:"targetType"`
}

type UserLoginInput struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type UserRegisterInput struct {
	Username       string `json:"username"`
	Password       string `json:"password"`
	RepeatPassword string `json:"repeatPassword"`
}

type CommunityType string

const (
	CommunityTypePublic     CommunityType = "Public"
	CommunityTypeRestricted CommunityType = "Restricted"
	CommunityTypePrivate    CommunityType = "Private"
)

var AllCommunityType = []CommunityType{
	CommunityTypePublic,
	CommunityTypeRestricted,
	CommunityTypePrivate,
}

func (e CommunityType) IsValid() bool {
	switch e {
	case CommunityTypePublic, CommunityTypeRestricted, CommunityTypePrivate:
		return true
	}
	return false
}

func (e CommunityType) String() string {
	return string(e)
}

func (e *CommunityType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommunityType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommunityType", str)
	}
	return nil
}

func (e CommunityType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Gender string

const (
	GenderMale   Gender = "MALE"
	GenderFemale Gender = "FEMALE"
)

var AllGender = []Gender{
	GenderMale,
	GenderFemale,
}

func (e Gender) IsValid() bool {
	switch e {
	case GenderMale, GenderFemale:
		return true
	}
	return false
}

func (e Gender) String() string {
	return string(e)
}

func (e *Gender) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Gender(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GENDER", str)
	}
	return nil
}

func (e Gender) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InputContentMode string

const (
	InputContentModeMarkDown   InputContentMode = "MarkDown"
	InputContentModeTextEditor InputContentMode = "TextEditor"
)

var AllInputContentMode = []InputContentMode{
	InputContentModeMarkDown,
	InputContentModeTextEditor,
}

func (e InputContentMode) IsValid() bool {
	switch e {
	case InputContentModeMarkDown, InputContentModeTextEditor:
		return true
	}
	return false
}

func (e InputContentMode) String() string {
	return string(e)
}

func (e *InputContentMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InputContentMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InputContentMode", str)
	}
	return nil
}

func (e InputContentMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MediaType string

const (
	MediaTypeImage MediaType = "Image"
	MediaTypeVideo MediaType = "Video"
)

var AllMediaType = []MediaType{
	MediaTypeImage,
	MediaTypeVideo,
}

func (e MediaType) IsValid() bool {
	switch e {
	case MediaTypeImage, MediaTypeVideo:
		return true
	}
	return false
}

func (e MediaType) String() string {
	return string(e)
}

func (e *MediaType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaType", str)
	}
	return nil
}

func (e MediaType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PostType string

const (
	PostTypePost       PostType = "Post"
	PostTypeImageVideo PostType = "Image_Video"
	PostTypeLink       PostType = "Link"
)

var AllPostType = []PostType{
	PostTypePost,
	PostTypeImageVideo,
	PostTypeLink,
}

func (e PostType) IsValid() bool {
	switch e {
	case PostTypePost, PostTypeImageVideo, PostTypeLink:
		return true
	}
	return false
}

func (e PostType) String() string {
	return string(e)
}

func (e *PostType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostType", str)
	}
	return nil
}

func (e PostType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortPostEnum string

const (
	SortPostEnumBest SortPostEnum = "BEST"
	SortPostEnumHot  SortPostEnum = "HOT"
	SortPostEnumNew  SortPostEnum = "NEW"
	SortPostEnumTop  SortPostEnum = "TOP"
)

var AllSortPostEnum = []SortPostEnum{
	SortPostEnumBest,
	SortPostEnumHot,
	SortPostEnumNew,
	SortPostEnumTop,
}

func (e SortPostEnum) IsValid() bool {
	switch e {
	case SortPostEnumBest, SortPostEnumHot, SortPostEnumNew, SortPostEnumTop:
		return true
	}
	return false
}

func (e SortPostEnum) String() string {
	return string(e)
}

func (e *SortPostEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortPostEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortPostEnum", str)
	}
	return nil
}

func (e SortPostEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserActionTargetType string

const (
	UserActionTargetTypePost    UserActionTargetType = "POST"
	UserActionTargetTypeComment UserActionTargetType = "COMMENT"
)

var AllUserActionTargetType = []UserActionTargetType{
	UserActionTargetTypePost,
	UserActionTargetTypeComment,
}

func (e UserActionTargetType) IsValid() bool {
	switch e {
	case UserActionTargetTypePost, UserActionTargetTypeComment:
		return true
	}
	return false
}

func (e UserActionTargetType) String() string {
	return string(e)
}

func (e *UserActionTargetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserActionTargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserActionTargetType", str)
	}
	return nil
}

func (e UserActionTargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserActionType string

const (
	UserActionTypeUpVote   UserActionType = "UpVote"
	UserActionTypeDownVote UserActionType = "DownVote"
)

var AllUserActionType = []UserActionType{
	UserActionTypeUpVote,
	UserActionTypeDownVote,
}

func (e UserActionType) IsValid() bool {
	switch e {
	case UserActionTypeUpVote, UserActionTypeDownVote:
		return true
	}
	return false
}

func (e UserActionType) String() string {
	return string(e)
}

func (e *UserActionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserActionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserActionType", str)
	}
	return nil
}

func (e UserActionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
